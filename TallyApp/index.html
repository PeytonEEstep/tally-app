<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#0f172a">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Tally">
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" href="icon-192.png">
  <link rel="apple-touch-icon" href="icon-192.png">
  <title>Tally Counter</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      -webkit-user-select: none;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overscroll-behavior: none;
      touch-action: pan-y;
      position: fixed;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    
    #root {
      width: 100%;
      height: 100%;
      overflow: auto;
    }

    input, textarea {
      user-select: text;
      -webkit-user-select: text;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="module">
    import React, { useState, useEffect } from 'https://esm.sh/react@18.2.0';
    import ReactDOM from 'https://esm.sh/react-dom@18.2.0/client';
    import * as LucideIcons from 'https://esm.sh/lucide-react@0.263.1';

    console.log("ðŸš€ System check: React is loading...");

    const COLORS = [
      { name: 'Slate', gradient: 'from-slate-500 to-slate-600', solid: 'bg-slate-500', text: 'text-slate-400', light: 'bg-slate-500/10', border: 'border-slate-500/30' },
      { name: 'Sky', gradient: 'from-sky-500 to-blue-600', solid: 'bg-sky-500', text: 'text-sky-400', light: 'bg-sky-500/10', border: 'border-sky-500/30' },
      { name: 'Emerald', gradient: 'from-emerald-500 to-green-600', solid: 'bg-emerald-500', text: 'text-emerald-400', light: 'bg-emerald-500/10', border: 'border-emerald-500/30' },
      { name: 'Violet', gradient: 'from-violet-500 to-purple-600', solid: 'bg-violet-500', text: 'text-violet-400', light: 'bg-violet-500/10', border: 'border-violet-500/30' },
      { name: 'Rose', gradient: 'from-rose-500 to-pink-600', solid: 'bg-rose-500', text: 'text-rose-400', light: 'bg-rose-500/10', border: 'border-rose-500/30' },
      { name: 'Amber', gradient: 'from-amber-500 to-orange-600', solid: 'bg-amber-500', text: 'text-amber-400', light: 'bg-amber-500/10', border: 'border-amber-500/30' },
      { name: 'Cyan', gradient: 'from-cyan-500 to-teal-600', solid: 'bg-cyan-500', text: 'text-cyan-400', light: 'bg-cyan-500/10', border: 'border-cyan-500/30' },
      { name: 'Fuchsia', gradient: 'from-fuchsia-500 to-pink-600', solid: 'bg-fuchsia-500', text: 'text-fuchsia-400', light: 'bg-fuchsia-500/10', border: 'border-fuchsia-500/30' },
    ];

    const THEMES = {
      dark: { name: 'Dark', bg: 'from-slate-950 via-slate-900 to-slate-950', card: 'bg-slate-900/80', cardSolid: 'bg-slate-900', border: 'border-slate-800', text: 'text-white', textSecondary: 'text-slate-400', textTertiary: 'text-slate-500', hover: 'hover:bg-slate-800', input: 'bg-slate-800', empty: 'bg-slate-800/50' },
      light: { name: 'Light', bg: 'from-slate-50 via-white to-slate-50', card: 'bg-white/90', cardSolid: 'bg-white', border: 'border-slate-200', text: 'text-slate-900', textSecondary: 'text-slate-600', textTertiary: 'text-slate-400', hover: 'hover:bg-slate-50', input: 'bg-slate-50', empty: 'bg-slate-100' },
      ocean: { name: 'Ocean', bg: 'from-blue-950 via-cyan-950 to-blue-950', card: 'bg-cyan-900/80', cardSolid: 'bg-cyan-900', border: 'border-cyan-800', text: 'text-white', textSecondary: 'text-cyan-300', textTertiary: 'text-cyan-500', hover: 'hover:bg-cyan-800', input: 'bg-cyan-800', empty: 'bg-cyan-800/50' },
      sunset: { name: 'Sunset', bg: 'from-orange-950 via-pink-950 to-purple-950', card: 'bg-pink-900/80', cardSolid: 'bg-pink-900', border: 'border-pink-800', text: 'text-white', textSecondary: 'text-pink-300', textTertiary: 'text-pink-500', hover: 'hover:bg-pink-800', input: 'bg-pink-800', empty: 'bg-pink-800/50' },
      forest: { name: 'Forest', bg: 'from-emerald-950 via-green-950 to-emerald-950', card: 'bg-emerald-900/80', cardSolid: 'bg-emerald-900', border: 'border-emerald-800', text: 'text-white', textSecondary: 'text-emerald-300', textTertiary: 'text-emerald-500', hover: 'hover:bg-emerald-800', input: 'bg-emerald-800', empty: 'bg-emerald-800/50' }
    };

    function TallyCounter() {
      const [folders, setFolders] = useState([]);
      const [counters, setCounters] = useState([]);
      const [activeCounter, setActiveCounter] = useState(null);
      const [currentView, setCurrentView] = useState('counters');
      const [currentFolder, setCurrentFolder] = useState(null);
      const [showHistory, setShowHistory] = useState(false);
      const [showCreateCounter, setShowCreateCounter] = useState(false);
      const [showCreateFolder, setShowCreateFolder] = useState(false);
      const [showMoveCounter, setShowMoveCounter] = useState(null);
      const [showExportSelection, setShowExportSelection] = useState(false);
      const [showEmailExport, setShowEmailExport] = useState(false);
      const [exportEmail, setExportEmail] = useState('');
      const [selectedForExport, setSelectedForExport] = useState([]);
      const [counterSort, setCounterSort] = useState('mostRecent');
      const [folderSort, setFolderSort] = useState('dateCreated');
      const [showSortMenu, setShowSortMenu] = useState(false);
      const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
      const [theme, setTheme] = useState('dark');
      const [leftHandedMode, setLeftHandedMode] = useState(false);
      const [importJson, setImportJson] = useState('');
      const [counterForm, setCounterForm] = useState({
        name: '', color: 1, folderId: null, reminderEnabled: false, reminderType: 'daily',
        reminderTime: '09:00', reminderInterval: 30, reminderIntervalUnit: 'minutes',
        goalEnabled: false, goalTarget: '', goalDeadline: '21:00', locked: false
      });
      const [folderForm, setFolderForm] = useState({ name: '', color: 1 });

      useEffect(() => {
        const savedState = localStorage.getItem('tallyAppState');
        if (savedState) {
          try {
            const parsed = JSON.parse(savedState);
            setFolders(parsed.folders || []);
            setCounters(parsed.counters || []);
            setTheme(parsed.theme || 'dark');
            setLeftHandedMode(parsed.leftHandedMode || false);
            setCounterSort(parsed.counterSort || 'mostRecent');
            setFolderSort(parsed.folderSort || 'dateCreated');
          } catch (e) {}
        }
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('sw.js');
        }
      }, []);

      useEffect(() => {
        const state = { folders, counters, theme, leftHandedMode, counterSort, folderSort };
        localStorage.setItem('tallyAppState', JSON.stringify(state));
        if (navigator.serviceWorker && navigator.serviceWorker.controller) {
          navigator.serviceWorker.controller.postMessage({ type: 'UPDATE_STATE', state: JSON.stringify(state) });
        }
      }, [folders, counters, theme, leftHandedMode, counterSort, folderSort]);

      const vibrate = () => { if (window.navigator.vibrate) window.navigator.vibrate(10); };

      const currentTheme = THEMES[theme];

      const resetCounterForm = () => {
        setCounterForm({ name: '', color: 1, folderId: currentFolder, reminderEnabled: false, reminderType: 'daily', reminderTime: '09:00', reminderInterval: 30, reminderIntervalUnit: 'minutes', goalEnabled: false, goalTarget: '', goalDeadline: '21:00', locked: false });
      };

      const resetFolderForm = () => { setFolderForm({ name: '', color: 1 }); };

      const addClick = (increment, counterId = null) => {
        vibrate();
        const targetId = counterId || activeCounter;
        const counter = counters.find(c => c.id === targetId);
        if (counter?.locked && counterId) return;
        setCounters(prev => prev.map(counter => {
          if (counter.id === targetId) {
            const newCount = counter.count + increment;
            if (newCount < 0) return counter;
            return { ...counter, count: newCount, lastUpdated: Date.now(), clicks: [...counter.clicks, { timestamp: new Date().toISOString(), value: increment }] };
          }
          return counter;
        }));
      };

      const resetCounter = () => {
        vibrate();
        setCounters(prev => prev.map(counter => counter.id === activeCounter ? { ...counter, count: 0, clicks: [] } : counter));
      };

      const createCounter = () => {
        vibrate();
        if (counterForm.name.trim()) {
          const newCounter = {
            id: Date.now(), name: counterForm.name, count: 0, clicks: [], color: counterForm.color,
            folderId: counterForm.folderId, locked: counterForm.locked, createdAt: Date.now(), lastUpdated: Date.now(),
            reminder: counterForm.reminderEnabled ? { type: counterForm.reminderType, time: counterForm.reminderTime, interval: counterForm.reminderInterval, unit: counterForm.reminderIntervalUnit } : null,
            goal: counterForm.goalEnabled ? { target: parseInt(counterForm.goalTarget) || 0, deadline: counterForm.goalDeadline } : null
          };
          setCounters([...counters, newCounter]);
          setShowCreateCounter(false);
          resetCounterForm();
          if (counterForm.reminderEnabled && 'Notification' in window) {
            Notification.requestPermission();
          }
        }
      };

      const createFolder = () => {
        vibrate();
        if (folderForm.name.trim()) {
          setFolders([...folders, { id: Date.now(), name: folderForm.name, color: folderForm.color, createdAt: Date.now() }]);
          setShowCreateFolder(false);
          resetFolderForm();
        }
      };

      const deleteCounter = (id, e) => {
        vibrate();
        e?.stopPropagation();
        setCounters(prev => prev.filter(c => c.id !== id));
        if (activeCounter === id) setActiveCounter(null);
      };

      const deleteFolder = (id) => {
        vibrate();
        setCounters(prev => prev.map(c => c.folderId === id ? { ...c, folderId: null } : c));
        setFolders(prev => prev.filter(f => f.id !== id));
        if (currentFolder === id) setCurrentFolder(null);
      };

      const deleteAllData = () => {
        vibrate();
        setCounters([]);
        setFolders([]);
        setActiveCounter(null);
        setCurrentFolder(null);
        setShowDeleteConfirm(false);
      };

      const toggleCounterLock = (id, e) => {
        vibrate();
        e?.stopPropagation();
        setCounters(prev => prev.map(c => c.id === id ? { ...c, locked: !c.locked } : c));
      };

      const moveCounter = (counterId, folderId) => {
        vibrate();
        setCounters(prev => prev.map(c => c.id === counterId ? { ...c, folderId } : c));
        setShowMoveCounter(null);
      };

      const getSortedCounters = () => {
        let sorted = [...counters];
        if (currentFolder !== null) sorted = sorted.filter(c => c.folderId === currentFolder);
        switch(counterSort) {
          case 'alphabetical': return sorted.sort((a, b) => a.name.localeCompare(b.name));
          case 'color': return sorted.sort((a, b) => a.color - b.color);
          case 'dateCreated': return sorted.sort((a, b) => b.createdAt - a.createdAt);
          case 'mostRecent':
          default: return sorted.sort((a, b) => (b.lastUpdated || b.createdAt) - (a.lastUpdated || a.createdAt));
        }
      };

      const getSortedFolders = () => {
        let sorted = [...folders];
        switch(folderSort) {
          case 'alphabetical': return sorted.sort((a, b) => a.name.localeCompare(b.name));
          case 'color': return sorted.sort((a, b) => a.color - b.color);
          case 'dateCreated':
          default: return sorted.sort((a, b) => b.createdAt - a.createdAt);
        }
      };

      const getAllLogs = () => {
        const logs = [];
        counters.forEach(counter => {
          counter.clicks.forEach(click => {
            logs.push({ counterName: counter.name, counterColor: counter.color, timestamp: click.timestamp, value: click.value });
          });
        });
        return logs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      };

      const generateCSV = (selectedCounters) => {
        const csvData = [];
        selectedCounters.forEach(counter => {
          csvData.push([`Counter: ${counter.name}`]);
          csvData.push(['Timestamp', 'Action', 'Count After']);
          let runningCount = 0;
          counter.clicks.forEach(click => {
            runningCount += click.value;
            csvData.push([new Date(click.timestamp).toLocaleString(), click.value > 0 ? `+${click.value}` : click.value, runningCount]);
          });
          csvData.push([]);
        });
        return csvData.map(row => row.join(',')).join('\n');
      };

      const exportToFile = () => {
        vibrate();
        const selectedCounters = counters.filter(c => selectedForExport.includes(c.id));
        const csv = generateCSV(selectedCounters);
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `counters_export_${Date.now()}.csv`;
        a.click();
        URL.revokeObjectURL(url);
        setShowExportSelection(false);
        setSelectedForExport([]);
      };

      const exportToEmail = () => {
        vibrate();
        const selectedCounters = counters.filter(c => selectedForExport.includes(c.id));
        const csv = generateCSV(selectedCounters);
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const subject = encodeURIComponent('Tally Counter Export');
        const body = encodeURIComponent(`Here is your counter data export.\n\nCounters included:\n${selectedCounters.map(c => `- ${c.name} (${c.count})`).join('\n')}\n\nNote: Please attach the downloaded CSV file to this email.`);
        window.location.href = `mailto:${exportEmail}?subject=${subject}&body=${body}`;
        const a = document.createElement('a');
        a.href = url;
        a.download = `counters_export_${Date.now()}.csv`;
        a.click();
        URL.revokeObjectURL(url);
        setShowEmailExport(false);
        setShowExportSelection(false);
        setSelectedForExport([]);
        setExportEmail('');
      };

      const exportBackup = () => {
        vibrate();
        const state = { folders, counters, theme, leftHandedMode, counterSort, folderSort, exportedAt: new Date().toISOString() };
        const json = JSON.stringify(state, null, 2);
        navigator.clipboard.writeText(json);
        alert('Backup copied to clipboard!');
      };

      const importBackup = () => {
        vibrate();
        try {
          const parsed = JSON.parse(importJson);
          setFolders(parsed.folders || []);
          setCounters(parsed.counters || []);
          setTheme(parsed.theme || 'dark');
          setLeftHandedMode(parsed.leftHandedMode || false);
          setCounterSort(parsed.counterSort || 'mostRecent');
          setFolderSort(parsed.folderSort || 'dateCreated');
          setImportJson('');
          alert('Backup restored successfully!');
        } catch (e) {
          alert('Invalid backup data');
        }
      };

      const getHistoryData = () => {
        const counter = counters.find(c => c.id === activeCounter);
        if (!counter) return [];
        const dailyData = {};
        counter.clicks.forEach(click => {
          const date = new Date(click.timestamp).toLocaleDateString();
          if (!dailyData[date]) dailyData[date] = { increments: 0, decrements: 0, total: 0 };
          if (click.value > 0) dailyData[date].increments += click.value;
          else dailyData[date].decrements += Math.abs(click.value);
          dailyData[date].total += click.value;
        });
        return Object.entries(dailyData).map(([date, data]) => ({ date, ...data })).sort((a, b) => new Date(b.date) - new Date(a.date));
      };

      const activeCounterData = counters.find(c => c.id === activeCounter);

      return React.createElement('div', { className: `min-h-screen bg-gradient-to-br ${currentTheme.bg} flex items-center justify-center p-4` },
        React.createElement('div', { className: 'w-full max-w-md mx-auto h-[700px] relative flex flex-col' },
          
          // --- 1. THE HEADER ---
          React.createElement('div', { className: 'flex justify-between items-center mb-6 px-2' },
            React.createElement('h1', { className: `text-3xl font-black ${currentTheme.text} tracking-tight` }, 'Tally'),
            React.createElement('div', { className: 'flex gap-2' },
              React.createElement('button', { 
                onClick: () => { vibrate(); setShowCreateCounter(true); },
                className: 'p-2 rounded-xl bg-blue-500 text-white shadow-lg shadow-blue-500/30'
              }, React.createElement(LucideIcons.Plus, { size: 24 }))
            )
          ),

          // --- 2. THE COUNTER LIST ---
          React.createElement('div', { className: 'flex-1 overflow-y-auto space-y-4 pb-20' },
            getSortedCounters().length === 0 ? 
              React.createElement('div', { className: `text-center py-20 ${currentTheme.textTertiary}` }, 
                React.createElement(LucideIcons.Hash, { size: 48, className: 'mx-auto mb-4 opacity-20' }),
                'No counters yet. Tap + to start.'
              ) : 
              getSortedCounters().map(counter => (
                React.createElement('div', { 
                  key: counter.id,
                  className: `${currentTheme.card} border ${currentTheme.border} p-5 rounded-3xl flex items-center justify-between transition-all active:scale-[0.98]`
                },
                  React.createElement('div', { className: 'flex flex-col' },
                    React.createElement('span', { className: `${currentTheme.textSecondary} text-xs font-bold uppercase tracking-widest mb-1` }, COLORS[counter.color].name),
                    React.createElement('span', { className: `${currentTheme.text} text-xl font-bold` }, counter.name)
                  ),
                  React.createElement('div', { className: 'flex items-center gap-4' },
                    React.createElement('button', { 
                      onClick: () => addClick(1, counter.id),
                      className: `w-14 h-14 rounded-2xl bg-gradient-to-br ${COLORS[counter.color].gradient} text-white flex items-center justify-center shadow-lg text-2xl font-bold`
                    }, '+'),
                    React.createElement('span', { className: `text-3xl font-black min-w-[3rem] text-center ${currentTheme.text}` }, counter.count)
                  )
                )
              ))
          ),

          // --- 3. YOUR CREATE MODAL (Keep this inside the main return) ---
          showCreateCounter && React.createElement('div', { className: 'absolute inset-0 bg-black/70 backdrop-blur-sm z-50 flex items-center justify-center p-4 rounded-3xl' },
            React.createElement('div', { className: `${currentTheme.cardSolid} rounded-2xl p-6 w-full max-h-full overflow-y-auto border ${currentTheme.border} shadow-2xl` },
              React.createElement('div', { className: 'flex justify-between items-center mb-6' },
                React.createElement('h2', { className: `text-xl font-semibold ${currentTheme.text}` }, 'Create Counter'),
                React.createElement('button', { onClick: () => { vibrate(); setShowCreateCounter(false); resetCounterForm(); }, className: `p-2 rounded-lg ${currentTheme.hover}` },
                  React.createElement(LucideIcons.X, { className: `w-5 h-5 ${currentTheme.textSecondary}` })
                )
              ),
              React.createElement('div', { className: 'space-y-4' },
                React.createElement('div', null,
                  React.createElement('label', { className: `text-sm font-medium ${currentTheme.textSecondary} mb-2 block` }, 'Name'),
                  React.createElement('input', { type: 'text', value: counterForm.name, onChange: (e) => setCounterForm({...counterForm, name: e.target.value}), placeholder: 'Counter Name', className: `w-full px-4 py-2.5 rounded-lg ${currentTheme.input} border ${currentTheme.border} ${currentTheme.text} focus:outline-none` })
                ),
                React.createElement('div', null,
                  React.createElement('label', { className: `text-sm font-medium ${currentTheme.textSecondary} mb-2 block` }, 'Color'),
                  React.createElement('div', { className: 'grid grid-cols-4 gap-2' },
                    COLORS.slice(0, 4).map((c, idx) => React.createElement('button', { key: idx, onClick: () => setCounterForm({...counterForm, color: idx}), className: `aspect-square rounded-lg bg-gradient-to-br ${c.gradient} ${counterForm.color === idx ? 'ring-2 ring-white' : ''}` }))
                  )
                ),
                React.createElement('button', { 
                  onClick: createCounter, 
                  className: 'w-full py-4 bg-blue-500 text-white font-bold rounded-xl mt-4' 
                }, 'Create Counter')
              )
            )
          )
        )
      );
    } // End of TallyCounter function

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(TallyCounter));
  </script>
</body>
</html>
